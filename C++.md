
### 变量和基本类型

#### 整形：表示整数，字符和布尔值的算术类型合称为整形

字符类型有两种：char（单个机器字节byte）和wchar_t（用于扩展字符集，比如汉字和日文）

1byte=8位

注意signed char和unsigned char

将超出取值范围的值赋给一个制定类型的对象时，对unsigned类型，编译器必须调整越界值使其满足要求，编译器会将该值对unsigned的可能取值数目求模，然后取所得值。例如unsigned char 8位，赋给超过255的值，会取该值对256求模后的值。336存8位得u char会得到80

#### 浮点型：float(32位)，double(64位)，long double(96or128bit)

tips：使用double基本不会有错，在float类型中隐式精度损失是不可忽略得，而双精度计算得代价相对于单精度可以忽略。

#### 字面值常量：称之为字面值是因为只能用它得值称呼它，称之为常量是因为它得值不能修改，每个字面值都有相应得类型

在数值后面加u或U定义unsigned 类型，同时加LU可以得到unsigned long类型得字面值常量。

在数值后面加上F表示单精度，加上L表示扩展精度eg,3.1415F,3.1415E0F,12.345L

可打印得字符型字面值通常用一对单引号来定义eg,'a','2'

在字符字面值前加L能得到wchar_t类型得宽字符字面值

c++中所有得字符串字面值都由编译器自动在末尾加一个空字符

| c++关键字  |              |                  |             |          |
| ---------- | ------------ | ---------------- | ----------- | -------- |
| asm        | do           | if               | return      | typedef  |
| auto       | double       | inline           | short       | typeid   |
| bool       | dynamic_cast | int              | signed      | typename |
| break      | else         | long             | sizeof      | union    |
| case       | enum         | mutable          | static      | unsigned |
| catch      | explicit     | namespace        | static_cast | using    |
| char       | export       | new              | struct      | virtual  |
| class      | extern       | operator         | switch      | void     |
| const      | false        | private          | template    | volatile |
| const_cast | float        | protected        | this        | wchar_t  |
| continue   | for          | public           | throw       | while    |
| default    | friend       | register         | true        |          |
| delete     | goto         | reinterpret_cast | try         |          |

 

dynamic_cast:将一个基类对象指针（或引用）cast到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理

对象初始化：直接初始化和复制初始化

```c++
int val(100);
int val1=100;
```

声明和定义：定义用于位变量分配存储空间，还可以为变量指定初始值，变量有且仅有一个定义

声明用于向程序表明变量的类型和名字。定义也是声明：当定义变量时我们声明了它的类型和名字。

可以使用extern关键字只声明不定义变量。

定义在函数外的名字具有全局作用域，除非特殊说明，在全局作用域声明的const变量是定义该对象的文件的局部变量。通过制定const变量为extern，就可以在整个程序中访问const对象

#### const限定符

const限定符把一个对象转换成一个常量。

const与引用的逻辑关系要搞清楚

引用：当引用初始化后只要该引用存在，它就绑定到初始化时所指向的对象，不能将引用绑定到另一个对象。

引用只是别名，作用在引用上的所有操作事实上都是作用在该引用绑定的对象上。

类定义后有一个分号

```c++
class name{
    public:
    ///
};
```

类中public部分定义的成员在程序的任何部分都可以访问，一般把操作放在public部分，这样程序的任何代码都可以执行这些操作。

不是类的组成部分的代码不能访问private成员。

#### 头文件

1.头文件用于声明而不是用于定义，有三个例外：头文件可以定义类，值在编译时就已知道的const对象和inline函数，这些实体可在多个源文件中定义，只要每个源文件中的定义是相同的。这些实体可以在多个源文件中定义，只要每个源文件中的定义是相同的。

#### 接口与实现

接口：由某种类型支持的操作。设计良好的类分离了接口和实现，在类的public部分定义接口 ，private部分定义实现。数据成员一般是实现的一部分，当函数成员是期望该类型的使用者使用的操作时，函数成员就是接口得到一部分，（因此为public）。当函数成员执行类所需要的非一般性使用的操作时，函数成员就是实现的一部分。

typedef 为某种类型引入同义词。

## 标准库类型

使用using声明可以在不需要加前缀namespace_name::的情况下访问命名空间中的名字。

string类型：

string对象可以相加，也可以直接和字面值连接，当进行string对象和字符串字面值混合连接操作时，+操作符的左右操作数必须至少有一个是string类型的。下标操作可用作左值。

```c++
string s1("hello");
string s2("world");
string s3=s1+s2;
s3=s1+"abc";
s3="a"+"b"//this is wrong!!!
s1[2]='c';
```

string对象中对单个字符进行处理，例如是否是字母，数字，空格，小写字母等等...详见P77

有些标准库是利用了c标准库，这些c标准库头文件命名形式为c+name，如c版name.h，c++版为cname表明这个库来源于C标准库。

vector类型：

vector是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。vector只能对已存在的元素进行下标操作。下标操作不能添加元素。添加元素应该使用push_back函数。

迭代器：

迭代器是一种检查容器内元素并遍历元素的数据类型。标准库为每一种容器都定义了一种迭代器类型。每个容器都定义了begin和end函数用于返回迭代器，分别指向第一个元素和最后一个元素。

任何改变vector长度得操作都会使已存在得迭代器失效。

## 数组和指针

c++程序被阉割限制于程序内部使用，只有当性能测试表明使用vector无法达到必要得到速度要求时，才使用数组。

数组得维数必须用值大于等于1的常量表达式定义。（非const变量以及要到运行阶段才知道值得const变量都不能用于定义数组得维数）

显式初始化数组元素时，把初值用花括号括起来，显示初始化得数组不需要制定数组的维数值。

指针：

对指针进行初始化或赋值只能使用以下四种类型的值：

1.0值常量表达式

2.类型匹配的对象的地址

3.另一对之后的下一地址

4.同类型的另一个有效指针

在表达式中使用数组名时，改名字会自动转换为指向数组第一个元素的指针。

可以使用数组初始化vector对象

```c++
const size_t arr_size=6;
int int_arr[arr_size]={0,1,2,3};
vector<int> ivec(int_arr,int_arr+4);
```

## 表达式

短路求值：逻辑与和逻辑或操作符总是先计算其左操作数，然后再计算其右操作数。只有在仅靠左操作数无法确定结果时，才会求解其右操作数。

箭头操作符：c++语言为包含点操作符和解引用操作符的表达式提供了一个同义词：箭头操作符（->）和点操作符。

强制类型转换：cast-name<type>(expression);cast-name为static_cast , dynamic_cast, const_cast, reinterpret_cast之一。

## 语句

对于switch语句，漏写break语句是常见的错误。

它的计算顺序如下:
(1) 循环开始时，执行一次init-statement (初始化语句)。在这个例子中，定义了ind,并将
它初始化为0。
(2)接着，求解condition (循环条件)。如果ind不等于svec.size0,则执行for循环体。
08否则， 循环结束。如果在第一次循环时，条件就为false,则不执行for循环体。
(3)如果条件为true,则执行for循环体。本例中，for 循环体输出当前元素值，并检验这
个元素是否是最后一个。如果不是，则输出一个空格，用于分隔当前元素和下一个元素。
(4) 最后，求解expression。本例中，ind 自增1。

## 函数

赋值实参的局限性：

- 当需要再函数中修改实参的值时
- 当需要以大型对象作为实参传递时，对实际的应用而言，复制对象所付出的时间和存储空间代价往往过大。
- 当没有办法实现对象的复制时

对于上述几种情况，有效的解决方法时将实参定义为引用或指针类型。

利用const引用可以避免复制

在向函数传递大型对象时，需要使用引用形参，这是引用形参适用的另一种情况。虽然复制实参对于内置数据类型的对象或者规模较小的类类型对象来说没有什么问题，但是对于大部分的 类类型或者大型数组，它的效率(通常)太低了；此外，我们将在第13章学习到，某些类类型 是无法复制的。使用引用形参，函数可以直接访问实参对象，而无须复制它。 

如果引用形参的唯一目的时避免复制实参，则应将形参定义为const引用。

非引用数组形参的类型检查只是确保实参是和数组元素具有同样类型的指针，而不会检查实参实际上是否指向指定大小的数组。

注意：f(int  (&arr)[10])才是正确的写法，两边的圆括号是必须的，因为下标操作符具有更高的优先级。

故传递给函数的数组的处理：

1.使用标准库规范

有三种常见的编程技巧确保函数的操作不超出数组实参的边界。第一种方法是在数组本身放置一个标记来检测数组的结束。C风格字符串就是采用这种方法的一个例子， 它是一种字符数组，并且以空字符null作为结束的标记。处理C风格字符串的程序就是使用这个标记停止数组元素的处理。
1.使用标准库规范
第二种方法是传递指向数组第个和最后一一个元素的下一个位置的指针 。这种编程风格由标
准库所使用的技术启发而得，在第一部分将会进一步介绍这种编程风格。
使用这种方法重写函数printValues并调用该函数，如下所示:

```c++
void printValues (const int *beg, const int *end)
while (beg != end) (
cout << *beg++ << end1;
nt main()
int j[2]
is converted 10 pointer 10 Oth elementin j
. (0，1):
1 ok:; scnersone past he endof j
11 j + 2 refers one|
printValues(j, j + 2);
return 0;
```

printValues中的循环很像用vetor迭代器编写的程序。每次循环都使beg指针指向下一个元素，从而实现遍历。

2.显示传递表示数组大小的形参

第三种方法是将第二个形参定义为表示数组的大小。

------

public：程序的所有部分都可以访问带有public的标号的 成员，类型的数据抽象试图由其public成员定义

private：实用类的代码不可以访问带有private标号的成员，类型的数据抽象试图由其public成员定义

protected：

数据集抽象：一种依赖于接口和实现分离的编程技术

封装：将低层次的元素组合起来形成新的高层次实体的技术

在类的内部定义的成语函数，例如不接受实参的get成员，将自动作为inline处理

类的定义以分号结束，因为类的定义之后可以接一个对象定义列表

静态局部对象：一个变量如果位于函数作用域内，但生命周期却跨越这个函数的多次调用，这种变量往往很有用，应该将这样的对象定义为static（静态的）。

static局部对象(static local object)确保不迟于在程序执行流程第一次经过该对象 的定义语句时进行初始化。这种对象一日被创建，在程序结束前都不会被撤销。当定义静态局部对象的函数结束时，静态局部对象不会撤销。在该函数被多次调用的过程中，静态局部对象会持续存在并保持它的值。考虑下面的小例子，这个函数计算了自己被调用的次数:

```c++
size_ t count_ calls()
static size. _t ctr = 0; 11 value will persist across callsreturn ++ctr;
int main()
for(size_ti=0;i!=10;++i)
cout << count_ calls() << endl;return 0;
```

这个程序会依次输出1到10 (包含10)的整数。
在第一次调用函数count. calls之前，ctr就已创建并赋予初值0。每次函数调用都使ctr加1，并且返回其当前值。在执行函数count. calls 时，变量ctr就已经存在并且保留上次调用该函数时的值。

内联函数：将函数指定为内联函数，通常就是将它在程序中每个调用点上“内联地”展开，从而消除了将功能写为函数的额外执行开销。-般来说，内联机制适用优化小的、只有几行的而且经常被调用的函数。将内联函数放入头文件中，P221

## 顺序容器

顺序容器：vector，list，deque

顺序容器适配器：stack，list，deque

容器元素的初始化

| C<T> c;    | 默认构造函数。如果C是一个array，则c中元素按默认方式初始化，否则c为空 |
| ---------- | ------------------------------------------------------------ |
| C c1(c2)   | c1初始化为c2的拷贝。c1和c2必须是相同类型（即，它们必须是相同的容器类型，且保存的是相同的元素类型；对于array类型，两者还必须具有相同的大小） |
| C c1=c2    | C c{a,b,c...}   c初始化为初始化列表中的元素的拷贝。列表中元素的类型必须与C的元素类型相容。对于array类型，列表中元素数目必须等于或小于array的大小，任何遗漏的元素都进行值初C c={a,b,c...} 始化 |
| C c(b,e)   | c初始化为迭代器b和e指定范围中的元素的拷贝。范围中元素的类型必须与C的元素类型相容（array不适用） |
| 👇          | 以下两个只有顺序容器适用                                     |
| C seq(n)   | seq包含n个元素，这些元素进行了值初始化；此构造函数是explicit的（string不适用） |
| C seq(n,t) | seq包含n个初始化为值t的元素                                  |

2.初始化为一段元素的副本

尽管不能直接将一种容器内的元素复制给另一种容器，但系统允许通过传递一堆迭代器间接实现该功能，使用迭代器时，不要求容器类型相同，容器内的元素类型也可以不同，只要他们相互兼容，能够将要复制的元素转换成所构建的新容器的元素类型，即可实现复制。

## 类

**this指针**：成员函数具有一个附加的隐含形参，即指向该类对象的一个指针。

在成员函数内部显式地引用this通常是不必要的，但有一种情况必须这样做：当我们需要将一个对象作为整体引用而不是引用对象的一个成员时。

成员只能通过对象或者指针分别使用成员访问操作符   .或->来访问

程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。 

**构造函数**：构造函数具有名字，形参表和函数体，与其他函数不同的是，构造函数还可以包含一个构造函数初始化列表。（const成员或引用类型的成员。因为const对象或引用类型只能初始化，不能对他们赋值 ），构造函数分两个阶段执行，（1）初始化阶段，（2）普通的计算阶段

友元：友元允许一个类将对其非公有成员的访问权授予指定的函数或类，

**static**：第一、在修饰变量的时候，static修饰的静态局部变量只执行一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。  第二、static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。  第三、static修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。Static修饰的局部变量存放在全局数据区的静态变量区。初始化的时候自动初始化为0；  

 C++中的**explicit**关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式). 

**virtual**:基类必须指出希望派生类重定义哪些函数，定义为virtual的函数是基类期待派生类重新定义的，基类希望派生类继承的函数不能定义为函数。

### 面对对象编程

1.继承

2.动态绑定

#### 定义基类和派生类

1.定义基类：积累成员函数，带有virtual保留字，用以启动动态绑定，除了构造函数之外，任何非static成员函数都可以是虚函数，

2.访问控制：public和private具有普通含义，用户代码可以访问public而不能访问private，private只能由基类的成员和友元访问，派生类对基类的public和private成员的访问权限与程序中任意其他部分一样：它可以访问public不能访问private。有时作为基类的类具有一些成员，它希望派生类访问但仍然禁止其他用户访问这些成员。也就是protected.

如果基类成员为public和protected，则派生列表中使用的访问标号决定该成员在派生类中的访问级别，：

如果是公用继承（）：基类成员保持自己的访问级别：基类的public成员为派生类的public成员，基类的protected成员为派生类的protected成员。

如果是受保护继承（）：基类成员保持自己的访问级别：基类的public和protected成员为派生类的protected成员	

如果是私有继承（）：基类成员保持自己的访问级别：基类的所有成员为派生类的private成员

友元不能继承，基类的友元对派生类的成员没有特殊访问权限。

### 模板与泛型编程

###C/C++中的预编译指令 

https://blog.csdn.net/sunshinewave/article/details/51020421

**句柄** 首先说指针吧。通俗一点就是地址，他是内存的编号，通过它我们可以直接对内存进行操作，只要地址不变，我们每次操作的物理位置是绝对不变，记住这句话，这是句柄和指针的重大区别所在。

　　再说说句柄吧，一般是指向系统的资源的位置，可以说也是地址。但是这些资源的位置真的不变，我们都知道windows支持虚拟内存的技术，同一时间内可能有些资源被换出内存，一些被换回来，这就是说同一资源在系统的不同时刻，他在内存的物理位置是不确定的，那么windows是如何解决这个问题呢，就是通过句柄来处理资源的物理位置不断变化的这个问题的。windows会在物理位置固定的区域存储一张对应表，表中记录了所有的资源实时地址，句柄其实没有直接指向资源的物理地址，而是指向了这个对应表中的一项，这样无论资源怎样的换进换出，通过句柄都可以找到他的实时位置。

### 宏c

\#define命令是C语言中的一个宏定义命令，它用来将一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本。例如\#define <宏名> (<参数表>) <宏体> #define  Load_Fun(fucname) GetProcAddress(hLib_, fucname) 

```
<< operator & >> operator
<<输出操作符。把右操作数写道左操作数制定的输出流：cout<<"hi"把hi写入到标准输出流。输出操作可以连接在一起使用：cout<<"hi"<<"hibye"
>>输入操作符。从左操作数制定的输入流读入数据到右操作数：cin>>i把标准输入流中的数据到右操作数：cin>>i把标准输入流中的写一个值读入到i中，输入操作能够连接在一起使用，例如cin>>i>>j;先读入i再读入j
::作用域符操作符。
```
