
### 变量和基本类型

#### 整形：表示整数，字符和布尔值的算术类型合称为整形

字符类型有两种：char（单个机器字节byte）和wchar_t（用于扩展字符集，比如汉字和日文）

1byte=8位

注意signed char和unsigned char

将超出取值范围的值赋给一个制定类型的对象时，对unsigned类型，编译器必须调整越界值使其满足要求，编译器会将该值对unsigned的可能取值数目求模，然后取所得值。例如unsigned char 8位，赋给超过255的值，会取该值对256求模后的值。336存8位得u char会得到80

#### 浮点型：float(32位)，double(64位)，long double(96or128bit)

tips：使用double基本不会有错，在float类型中隐式精度损失是不可忽略得，而双精度计算得代价相对于单精度可以忽略。

#### 字面值常量：称之为字面值是因为只能用它得值称呼它，称之为常量是因为它得值不能修改，每个字面值都有相应得类型

在数值后面加u或U定义unsigned 类型，同时加LU可以得到unsigned long类型得字面值常量。

在数值后面加上F表示单精度，加上L表示扩展精度eg,3.1415F,3.1415E0F,12.345L

可打印得字符型字面值通常用一对单引号来定义eg,'a','2'

在字符字面值前加L能得到wchar_t类型得宽字符字面值

c++中所有得字符串字面值都由编译器自动在末尾加一个空字符

| c++关键字  |              |                  |             |          |
| ---------- | ------------ | ---------------- | ----------- | -------- |
| asm        | do           | if               | return      | typedef  |
| auto       | double       | inline           | short       | typeid   |
| bool       | dynamic_cast | int              | signed      | typename |
| break      | else         | long             | sizeof      | union    |
| case       | enum         | mutable          | static      | unsigned |
| catch      | explicit     | namespace        | static_cast | using    |
| char       | export       | new              | struct      | virtual  |
| class      | extern       | operator         | switch      | void     |
| const      | false        | private          | template    | volatile |
| const_cast | float        | protected        | this        | wchar_t  |
| continue   | for          | public           | throw       | while    |
| default    | friend       | register         | true        |          |
| delete     | goto         | reinterpret_cast | try         |          |

 

dynamic_cast:将一个基类对象指针（或引用）cast到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理

对象初始化：直接初始化和复制初始化

```c++
int val(100);
int val1=100;
```

声明和定义：定义用于位变量分配存储空间，还可以为变量指定初始值，变量有且仅有一个定义

声明用于向程序表明变量的类型和名字。定义也是声明：当定义变量时我们声明了它的类型和名字。

可以使用extern关键字只声明不定义变量。

定义在函数外的名字具有全局作用域，除非特殊说明，在全局作用域声明的const变量是定义该对象的文件的局部变量。通过制定const变量为extern，就可以在整个程序中访问const对象

#### const限定符

const限定符把一个对象转换成一个常量。

const与引用的逻辑关系要搞清楚

引用：当引用初始化后只要该引用存在，它就绑定到初始化时所指向的对象，不能将引用绑定到另一个对象。

引用只是别名，作用在引用上的所有操作事实上都是作用在该引用绑定的对象上。

类定义后有一个分号

```c++
class name{
    public:
    ///
};
```

类中public部分定义的成员在程序的任何部分都可以访问，一般把操作放在public部分，这样程序的任何代码都可以执行这些操作。

不是类的组成部分的代码不能访问private成员。

#### 头文件

1.头文件用于声明而不是用于定义，有三个例外：头文件可以定义类，值在编译时就已知道的const对象和inline函数，这些实体可在多个源文件中定义，只要每个源文件中的定义是相同的。这些实体可以在多个源文件中定义，只要每个源文件中的定义是相同的。

#### 接口与实现

接口：由某种类型支持的操作。设计良好的类分离了接口和实现，在类的public部分定义接口 ，private部分定义实现。数据成员一般是实现的一部分，当函数成员是期望该类型的使用者使用的操作时，函数成员就是接口得到一部分，（因此为public）。当函数成员执行类所需要的非一般性使用的操作时，函数成员就是实现的一部分。

typedef 为某种类型引入同义词。

## 标准库类型

使用using声明可以在不需要加前缀namespace_name::的情况下访问命名空间中的名字。

string类型：

string对象可以相加，也可以直接和字面值连接，当进行string对象和字符串字面值混合连接操作时，+操作符的左右操作数必须至少有一个是string类型的。下标操作可用作左值。

```c++
string s1("hello");
string s2("world");
string s3=s1+s2;
s3=s1+"abc";
s3="a"+"b"//this is wrong!!!
s1[2]='c';
```

string对象中对单个字符进行处理，例如是否是字母，数字，空格，小写字母等等...详见P77

有些标准库是利用了c标准库，这些c标准库头文件命名形式为c+name，如c版name.h，c++版为cname表明这个库来源于C标准库。

vector类型：

vector是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。vector只能对已存在的元素进行下标操作。下标操作不能添加元素。添加元素应该使用push_back函数。

迭代器：

迭代器是一种检查容器内元素并遍历元素的数据类型。标准库为每一种容器都定义了一种迭代器类型。每个容器都定义了begin和end函数用于返回迭代器，分别指向第一个元素和最后一个元素。

任何改变vector长度得操作都会使已存在得迭代器失效。

## 数组和指针

c++程序被阉割限制于程序内部使用，只有当性能测试表明使用vector无法达到必要得到速度要求时，才使用数组。

数组得维数必须用值大于等于1的常量表达式定义。（非const变量以及要到运行阶段才知道值得const变量都不能用于定义数组得维数）

显式初始化数组元素时，把初值用花括号括起来，显示初始化得数组不需要制定数组的维数值。

指针：

对指针进行初始化或赋值只能使用以下四种类型的值：

1.0值常量表达式

2.类型匹配的对象的地址

3.另一对之后的下一地址

4.同类型的另一个有效指针

在表达式中使用数组名时，改名字会自动转换为指向数组第一个元素的指针。

可以使用数组初始化vector对象

```c++
const size_t arr_size=6;
int int_arr[arr_size]={0,1,2,3};
vector<int> ivec(int_arr,int_arr+4);
```

## 表达式

短路求值：逻辑与和逻辑或操作符总是先计算其左操作数，然后再计算其右操作数。只有在仅靠左操作数无法确定结果时，才会求解其右操作数。

箭头操作符：c++语言为包含点操作符和解引用操作符的表达式提供了一个同义词：箭头操作符（->）和点操作符。

强制类型转换：cast-name<type>(expression);cast-name为static_cast , dynamic_cast, const_cast, reinterpret_cast之一。

## 语句

对于switch语句，漏写break语句是常见的错误。

它的计算顺序如下:
(1) 循环开始时，执行一次init-statement (初始化语句)。在这个例子中，定义了ind,并将
它初始化为0。
(2)接着，求解condition (循环条件)。如果ind不等于svec.size0,则执行for循环体。
08否则， 循环结束。如果在第一次循环时，条件就为false,则不执行for循环体。
(3)如果条件为true,则执行for循环体。本例中，for 循环体输出当前元素值，并检验这
个元素是否是最后一个。如果不是，则输出一个空格，用于分隔当前元素和下一个元素。
(4) 最后，求解expression。本例中，ind 自增1。

## 函数

赋值实参的局限性：

- 当需要再函数中修改实参的值时
- 当需要以大型对象作为实参传递时，对实际的应用而言，复制对象所付出的时间和存储空间代价往往过大。
- 当没有办法实现对象的复制时

对于上述几种情况，有效的解决方法时将实参定义为引用或指针类型。

利用const引用可以避免复制

在向函数传递大型对象时，需要使用引用形参，这是引用形参适用的另一种情况。虽然复制实参对于内置数据类型的对象或者规模较小的类类型对象来说没有什么问题，但是对于大部分的 类类型或者大型数组，它的效率(通常)太低了；此外，我们将在第13章学习到，某些类类型 是无法复制的。使用引用形参，函数可以直接访问实参对象，而无须复制它。 

如果引用形参的唯一目的时避免复制实参，则应将形参定义为const引用。

非引用数组形参的类型检查只是确保实参是和数组元素具有同样类型的指针，而不会检查实参实际上是否指向指定大小的数组。

注意：f(int  (&arr)[10])才是正确的写法，两边的圆括号是必须的，因为下标操作符具有更高的优先级。

故传递给函数的数组的处理：

1.使用标准库规范

有三种常见的编程技巧确保函数的操作不超出数组实参的边界。第一种方法是在数组本身放置一个标记来检测数组的结束。C风格字符串就是采用这种方法的一个例子， 它是一种字符数组，并且以空字符null作为结束的标记。处理C风格字符串的程序就是使用这个标记停止数组元素的处理。
1.使用标准库规范
第二种方法是传递指向数组第个和最后一一个元素的下一个位置的指针 。这种编程风格由标
准库所使用的技术启发而得，在第一部分将会进一步介绍这种编程风格。
使用这种方法重写函数printValues并调用该函数，如下所示:

```c++
void printValues (const int *beg, const int *end)
while (beg != end) (
cout << *beg++ << end1;
nt main()
int j[2]
is converted 10 pointer 10 Oth elementin j
. (0，1):
1 ok:; scnersone past he endof j
11 j + 2 refers one|
printValues(j, j + 2);
return 0;
```

printValues中的循环很像用vetor迭代器编写的程序。每次循环都使beg指针指向下一个元素，从而实现遍历。

2.显示传递表示数组大小的形参

第三种方法是将第二个形参定义为表示数组的大小。

------

public：程序的所有部分都可以访问带有public的标号的 成员，类型的数据抽象试图由其public成员定义

private：实用类的代码不可以访问带有private标号的成员，类型的数据抽象试图由其public成员定义

protected：

数据集抽象：一种依赖于接口和实现分离的编程技术

封装：将低层次的元素组合起来形成新的高层次实体的技术

在类的内部定义的成语函数，例如不接受实参的get成员，将自动作为inline处理

类的定义以分号结束，因为类的定义之后可以接一个对象定义列表

静态局部对象：一个变量如果位于函数作用域内，但生命周期却跨越这个函数的多次调用，这种变量往往很有用，应该将这样的对象定义为static（静态的）。

static局部对象(static local object)确保不迟于在程序执行流程第一次经过该对象 的定义语句时进行初始化。这种对象一日被创建，在程序结束前都不会被撤销。当定义静态局部对象的函数结束时，静态局部对象不会撤销。在该函数被多次调用的过程中，静态局部对象会持续存在并保持它的值。考虑下面的小例子，这个函数计算了自己被调用的次数:

```c++
size_ t count_ calls()
static size. _t ctr = 0; 11 value will persist across callsreturn ++ctr;
int main()
for(size_ti=0;i!=10;++i)
cout << count_ calls() << endl;return 0;
```

这个程序会依次输出1到10 (包含10)的整数。
在第一次调用函数count. calls之前，ctr就已创建并赋予初值0。每次函数调用都使ctr加1，并且返回其当前值。在执行函数count. calls 时，变量ctr就已经存在并且保留上次调用该函数时的值。

内联函数：将函数指定为内联函数，通常就是将它在程序中每个调用点上“内联地”展开，从而消除了将功能写为函数的额外执行开销。-般来说，内联机制适用优化小的、只有几行的而且经常被调用的函数。将内联函数放入头文件中，P221

## 顺序容器

顺序容器：vector(支持快速随机访问)，list(支持快速插入删除)，deque(双端队列)

顺序容器适配器：stack(后进先出LIFO栈)，queue(先进先出FIFO队列)，priority_queue(有优先级管理的队列)

容器元素的初始化

| C<T> c;    | 默认构造函数。如果C是一个array，则c中元素按默认方式初始化，否则c为空 |
| ---------- | ------------------------------------------------------------ |
| C c1(c2)   | c1初始化为c2的拷贝。c1和c2必须是相同类型（即，它们必须是相同的容器类型，且保存的是相同的元素类型；对于array类型，两者还必须具有相同的大小） |
| C c1=c2    | C c{a,b,c...}   c初始化为初始化列表中的元素的拷贝。列表中元素的类型必须与C的元素类型相容。对于array类型，列表中元素数目必须等于或小于array的大小，任何遗漏的元素都进行值初C c={a,b,c...} 始化 |
| C c(b,e)   | c初始化为迭代器b和e指定范围中的元素的拷贝。范围中元素的类型必须与C的元素类型相容（array不适用） |
| 👇          | 以下两个只有顺序容器适用                                     |
| C seq(n)   | seq包含n个元素，这些元素进行了值初始化；此构造函数是explicit的（string不适用） |
| C seq(n,t) | seq包含n个初始化为值t的元素                                  |

2.初始化为一段元素的副本

尽管不能直接将一种容器内的元素复制给另一种容器，但系统允许通过传递一堆迭代器间接实现该功能，使用迭代器时，不要求容器类型相同，容器内的元素类型也可以不同，只要他们相互兼容，能够将要复制的元素转换成所构建的新容器的元素类型，即可实现复制。

## 泛型算法

**<一> 查找算法(13个)：判断容器中是否包含某个值** 
adjacent_find: 在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。 
binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。 
count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。 
count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。 
equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。 
find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的一个InputIterator。 
find_end: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”的最后一次出现。找到则返回最后一对的第一个ForwardIterator，否则返回输入的”另外一对”的第一个ForwardIterator。重载版本使用用户输入的操作符代替等于操作。 
find_first_of: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使用了用户自定义操作符。 
find_if: 使用输入的函数代替等于操作符执行find。 
lower_bound: 返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函数使用自定义比较操作。 
upper_bound: 返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志一个大于value的值。重载函数使用自定义比较操作。 
search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1。重载版本使用自定义的比较操作。 
search_n: 在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。 
**<二> 排序和通用算法(14个)：提供元素排序策略** 
inplace_merge: 合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。 
merge: 合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。 
nth_element: 将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作。 
partial_sort: 对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。 
partial_sort_copy: 与partial_sort类似，不过将经过排序的序列复制到另一个容器。 
partition: 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。 
random_shuffle: 对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。 
reverse: 将指定范围内元素重新反序排序。 
reverse_copy: 与reverse类似，不过将结果写入另一个容器。 
rotate: 将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。 
rotate_copy: 与rotate类似，不过将结果写入另一个容器。 
sort: 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。 
stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。 
stable_partition: 与partition类似，不过不保证保留容器中的相对顺序。 
**<三> 删除和替换算法(15个)** 
copy: 复制序列 
copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。 
iter_swap: 交换两个ForwardIterator的值。 
remove: 删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove_if函数。 
remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。 
remove_if: 删除指定范围内输入操作结果为true的所有元素。 
remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。 
replace: 将指定范围内所有等于vold的元素都用vnew代替。 
replace_copy: 与replace类似，不过将结果写入另一个容器。 
replace_if: 将指定范围内所有操作结果为true的元素用新值代替。 
replace_copy_if: 与replace_if，不过将结果写入另一个容器。 
swap: 交换存储在两个对象中的值。 
swap_range: 将指定范围内的元素与另一个序列元素值进行交换。 
unique: 清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。 
unique_copy: 与unique类似，不过把结果输出到另一个容器。 
**<四> 排列组合算法(2个)**： 
提供计算给定集合按一定顺序的所有可能排列组合 
next_permutation: 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。 
prev_permutation: 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。 
**<五> 算术算法(4个)** 
accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。 
partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。 
inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。 
adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。 
**<六> 生成和异变算法(6个)** 
fill: 将输入值赋给标志范围内的所有元素。 
fill_n: 将输入值赋给first到first+n范围内的所有元素。 
for_each: 用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。 
generate: 连续调用输入的函数来填充指定的范围。 
generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。 
transform: 将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。 
**<七> 关系算法(8个)** 
equal: 如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。 
includes: 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的<操作符，成功返回true。重载版本使用用户输入的函数。 
lexicographical_compare: 比较两个序列。重载版本使用用户自定义比较操作。 
max: 返回两个元素中较大一个。重载版本使用自定义比较操作。 
max_element: 返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。 
min: 返回两个元素中较小一个。重载版本使用自定义比较操作。 
min_element: 返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。 
mismatch: 并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。

**<八> 集合算法(4个)** 
set_union: 构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。 
set_intersection: 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。 
set_difference: 构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用自定义的比较操作。 
set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。

**<九> 堆算法(4个)** 
make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。 
pop_heap: 并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被”弹出”的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。 
push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。 
sort_heap: 对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。	

## 类

**this指针**：成员函数具有一个附加的隐含形参，即指向该类对象的一个指针。

在成员函数内部显式地引用this通常是不必要的，但有一种情况必须这样做：当我们需要将一个对象作为整体引用而不是引用对象的一个成员时。

成员只能通过对象或者指针分别使用成员访问操作符   .或->来访问

程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。 

**构造函数**：构造函数具有名字，形参表和函数体，与其他函数不同的是，构造函数还可以包含一个构造函数初始化列表。（const成员或引用类型的成员。因为const对象或引用类型只能初始化，不能对他们赋值 ），构造函数分两个阶段执行，（1）初始化阶段，（2）普通的计算阶段

友元：友元允许一个类将对其非公有成员的访问权授予指定的函数或类，

**static**：第一、在修饰变量的时候，static修饰的静态局部变量只执行一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。  第二、static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。  第三、static修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。Static修饰的局部变量存放在全局数据区的静态变量区。初始化的时候自动初始化为0；  

 C++中的**explicit**关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式). 

**virtual**:基类必须指出希望派生类重定义哪些函数，定义为virtual的函数是基类期待派生类重新定义的，基类希望派生类继承的函数不能定义为函数。

### 面对对象编程

1.继承

2.动态绑定

#### 定义基类和派生类

1.定义基类：积累成员函数，带有virtual保留字，用以启动动态绑定，除了构造函数之外，任何非static成员函数都可以是虚函数，

2.访问控制：public和private具有普通含义，用户代码可以访问public而不能访问private，private只能由基类的成员和友元访问，派生类对基类的public和private成员的访问权限与程序中任意其他部分一样：它可以访问public不能访问private。有时作为基类的类具有一些成员，它希望派生类访问但仍然禁止其他用户访问这些成员。也就是protected.

如果基类成员为public和protected，则派生列表中使用的访问标号决定该成员在派生类中的访问级别，：

如果是公用继承（）：基类成员保持自己的访问级别：基类的public成员为派生类的public成员，基类的protected成员为派生类的protected成员。

如果是受保护继承（）：基类成员保持自己的访问级别：基类的public和protected成员为派生类的protected成员	

如果是私有继承（）：基类成员保持自己的访问级别：基类的所有成员为派生类的private成员

友元不能继承，基类的友元对派生类的成员没有特殊访问权限。

### 模板与泛型编程

###C/C++中的预编译指令 

https://blog.csdn.net/sunshinewave/article/details/51020421

**句柄** 首先说指针吧。通俗一点就是地址，他是内存的编号，通过它我们可以直接对内存进行操作，只要地址不变，我们每次操作的物理位置是绝对不变，记住这句话，这是句柄和指针的重大区别所在。

　　再说说句柄吧，一般是指向系统的资源的位置，可以说也是地址。但是这些资源的位置真的不变，我们都知道windows支持虚拟内存的技术，同一时间内可能有些资源被换出内存，一些被换回来，这就是说同一资源在系统的不同时刻，他在内存的物理位置是不确定的，那么windows是如何解决这个问题呢，就是通过句柄来处理资源的物理位置不断变化的这个问题的。windows会在物理位置固定的区域存储一张对应表，表中记录了所有的资源实时地址，句柄其实没有直接指向资源的物理地址，而是指向了这个对应表中的一项，这样无论资源怎样的换进换出，通过句柄都可以找到他的实时位置。

### 宏c

\#define命令是C语言中的一个宏定义命令，它用来将一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本。例如\#define <宏名> (<参数表>) <宏体> #define  Load_Fun(fucname) GetProcAddress(hLib_, fucname) 

```
<< operator & >> operator
<<输出操作符。把右操作数写道左操作数制定的输出流：cout<<"hi"把hi写入到标准输出流。输出操作可以连接在一起使用：cout<<"hi"<<"hibye"
>>输入操作符。从左操作数制定的输入流读入数据到右操作数：cin>>i把标准输入流中的数据到右操作数：cin>>i把标准输入流中的写一个值读入到i中，输入操作能够连接在一起使用，例如cin>>i>>j;先读入i再读入j
::作用域符操作符。
```

This paper proposed a novel architecture combines DenseNet，Inception module and fully convolution network for high resolution remote-sensing image semantic segmentation. Additionally this model takes both spectral data and DSMs data as input to obtain a better result.

Deeplab V3+ is also a powerful model for semantic segmentation, it will be better if you may offer the result comparison of it.

