public：程序的所有部分都可以访问带有public的标号的 成员，类型的数据抽象试图由其public成员定义

private：实用类的代码不可以访问带有private标号的成员，类型的数据抽象试图由其public成员定义

protected：

数据集抽象：一种依赖于接口和实现分离的编程技术

封装：将低层次的元素组合起来形成新的高层次实体的技术

在类的内部定义的成语函数，例如不接受实参的get成员，将自动作为inline处理

类的定义以分号结束，因为类的定义之后可以接一个对象定义列表

类

**this指针**：成员函数具有一个附加的隐含形参，即指向该类对象的一个指针。

在成员函数内部显式地引用this通常是不必要的，但有一种情况必须这样做：当我们需要将一个对象作为整体引用而不是引用对象的一个成员时。

成员只能通过对象或者指针分别使用成员访问操作符   .或->来访问

程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。 

**构造函数**：构造函数具有名字，形参表和函数体，与其他函数不同的是，构造函数还可以包含一个构造函数初始化列表。（const成员或引用类型的成员。因为const对象或引用类型只能初始化，不能对他们赋值 ），构造函数分两个阶段执行，（1）初始化阶段，（2）普通的计算阶段

友元：友元允许一个类将对其非公有成员的访问权授予指定的函数或类，

**static**：第一、在修饰变量的时候，static修饰的静态局部变量只执行一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。  第二、static修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是extern外部声明也不可以。  第三、static修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。Static修饰的局部变量存放在全局数据区的静态变量区。初始化的时候自动初始化为0；  

 C++中的**explicit**关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式). 

**virtual**:基类必须指出希望派生类重定义哪些函数，定义为virtual的函数是基类期待派生类重新定义的，基类希望派生类继承的函数不能定义为函数。

### 面对对象编程

1.继承

2.动态绑定

#### 定义基类和派生类

1.定义基类：积累成员函数，带有virtual保留字，用以启动动态绑定，除了构造函数之外，任何非static成员函数都可以是虚函数，

2.访问控制：public和private具有普通含义，用户代码可以访问public而不能访问private，private只能由基类的成员和友元访问，派生类对基类的public和private成员的访问权限与程序中任意其他部分一样：它可以访问public不能访问private。有时作为基类的类具有一些成员，它希望派生类访问但仍然禁止其他用户访问这些成员。也就是protected.

如果基类成员为public和protected，则派生列表中使用的访问标号决定该成员在派生类中的访问级别，：

如果是公用继承（）：基类成员保持自己的访问级别：基类的public成员为派生类的public成员，基类的protected成员为派生类的protected成员。

如果是受保护继承（）：基类成员保持自己的访问级别：基类的public和protected成员为派生类的protected成员	

如果是私有继承（）：基类成员保持自己的访问级别：基类的所有成员为派生类的private成员

友元不能继承，基类的友元对派生类的成员没有特殊访问权限。

### 模板与泛型编程

###C/C++中的预编译指令 

https://blog.csdn.net/sunshinewave/article/details/51020421

**句柄** 首先说指针吧。通俗一点就是地址，他是内存的编号，通过它我们可以直接对内存进行操作，只要地址不变，我们每次操作的物理位置是绝对不变，记住这句话，这是句柄和指针的重大区别所在。

　　再说说句柄吧，一般是指向系统的资源的位置，可以说也是地址。但是这些资源的位置真的不变，我们都知道windows支持虚拟内存的技术，同一时间内可能有些资源被换出内存，一些被换回来，这就是说同一资源在系统的不同时刻，他在内存的物理位置是不确定的，那么windows是如何解决这个问题呢，就是通过句柄来处理资源的物理位置不断变化的这个问题的。windows会在物理位置固定的区域存储一张对应表，表中记录了所有的资源实时地址，句柄其实没有直接指向资源的物理地址，而是指向了这个对应表中的一项，这样无论资源怎样的换进换出，通过句柄都可以找到他的实时位置。

### 宏c



\#define命令是C语言中的一个宏定义命令，它用来将一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本。例如\#define <宏名> (<参数表>) <宏体> #define  Load_Fun(fucname) GetProcAddress(hLib_, fucname) 

```
<< operator & >> operator
<<输出操作符。把右操作数写道左操作数制定的输出流：cout<<"hi"把hi写入到标准输出流。输出操作可以连接在一起使用：cout<<"hi"<<"hibye"
>>输入操作符。从左操作数制定的输入流读入数据到右操作数：cin>>i把标准输入流中的数据到右操作数：cin>>i把标准输入流中的写一个值读入到i中，输入操作能够连接在一起使用，例如cin>>i>>j;先读入i再读入j
::作用域符操作符。
```

### 变量和基本类型

#### 整形：表示整数，字符和布尔值的算术类型合称为整形

字符类型有两种：char（单个机器字节byte）和wchar_t（用于扩展字符集，比如汉字和日文）

1byte=8位

注意signed char和unsigned char

将超出取值范围的值赋给一个制定类型的对象时，对unsigned类型，编译器必须调整越界值使其满足要求，编译器会将该值对unsigned的可能取值数目求模，然后取所得值。例如unsigned char 8位，赋给超过255的值，会取该值对256求模后的值。336存8位得u char会得到80

#### 浮点型：float(32位)，double(64位)，long double(96or128bit)

tips：使用double基本不会有错，在float类型中隐式精度损失是不可忽略得，而双精度计算得代价相对于单精度可以忽略。

#### 字面值常量：称之为字面值是因为只能用它得值称呼它，称之为常量是因为它得值不能修改，每个字面值都有相应得类型

在数值后面加u或U定义unsigned 类型，同时加LU可以得到unsigned long类型得字面值常量。

在数值后面加上F表示单精度，加上L表示扩展精度eg,3.1415F,3.1415E0F,12.345L

可打印得字符型字面值通常用一对单引号来定义eg,'a','2'

在字符字面值前加L能得到wchar_t类型得宽字符字面值

c++中所有得字符串字面值都由编译器自动在末尾加一个空字符

| c++关键字  |              |                  |             |          |
| ---------- | ------------ | ---------------- | ----------- | -------- |
| asm        | do           | if               | return      | typedef  |
| auto       | double       | inline           | short       | typeid   |
| bool       | dynamic_cast | int              | signed      | typename |
| break      | else         | long             | sizeof      | union    |
| case       | enum         | mutable          | static      | unsigned |
| catch      | explicit     | namespace        | static_cast | using    |
| char       | export       | new              | struct      | virtual  |
| class      | extern       | operator         | switch      | void     |
| const      | false        | private          | template    | volatile |
| const_cast | float        | protected        | this        | wchar_t  |
| continue   | for          | public           | throw       | while    |
| default    | friend       | register         | true        |          |
| delete     | goto         | reinterpret_cast | try         |          |

 

dynamic_cast:将一个基类对象指针（或引用）cast到继承类指针，dynamic_cast会根据基类指针是否真正指向继承类指针来做相应处理

对象初始化：直接初始化和复制初始化

```c++
int val(100);
int val1=100;
```

声明和定义：定义用于位变量分配存储空间，还可以为变量指定初始值，变量有且仅有一个定义

声明用于向程序表明变量的类型和名字。定义也是声明：当定义变量时我们声明了它的类型和名字。

可以使用extern关键字只声明不定义变量。

定义在函数外的名字具有全局作用域，除非特殊说明，在全局作用域声明的const变量是定义该对象的文件的局部变量。通过制定const变量为extern，就可以在整个程序中访问const对象

#### const限定符

const限定符把一个对象转换成一个常量。

const与引用的逻辑关系要搞清楚

引用：当引用初始化后只要该引用存在，它就绑定到初始化时所指向的对象，不能将引用绑定到另一个对象。

引用只是别名，作用在引用上的所有操作事实上都是作用在该引用绑定的对象上。

类定义后有一个分号

```c++
class name{
    public:
    ///
};
```

类中public部分定义的成员在程序的任何部分都可以访问，一般把操作放在public部分，这样程序的任何代码都可以执行这些操作。

不是类的组成部分的代码不能访问private成员。

#### 头文件

1.头文件用于声明而不是用于定义，有三个例外：头文件可以定义类，值在编译时就已知道的const对象和inline函数，这些实体可在多个源文件中定义，只要每个源文件中的定义是相同的。这些实体可以在多个源文件中定义，只要每个源文件中的定义是相同的。

#### 接口与实现

接口：由某种类型支持的操作。设计良好的类分离了接口和实现，在类的public部分定义接口 ，private部分定义实现。数据成员一般是实现的一部分，当函数成员是期望该类型的使用者使用的操作时，函数成员就是接口得到一部分，（因此为public）。当函数成员执行类所需要的非一般性使用的操作时，函数成员就是实现的一部分。

typedef 为某种类型引入同义词。

## 标准库类型

使用using声明可以在不需要加前缀namespace_name::的情况下访问命名空间中的名字。

string类型：

string对象可以相加，也可以直接和字面值连接，当进行string对象和字符串字面值混合连接操作时，+操作符的左右操作数必须至少有一个是string类型的。下标操作可用作左值。

```c++
string s1("hello");
string s2("world");
string s3=s1+s2;
s3=s1+"abc";
s3="a"+"b"//this is wrong!!!
s1[2]='c';
```

string对象中对单个字符进行处理，例如是否是字母，数字，空格，小写字母等等...详见P77

有些标准库是利用了c标准库，这些c标准库头文件命名形式为c+name，如c版name.h，c++版为cname表明这个库来源于C标准库。

vector类型：

vector是同一种类型的对象的集合，每个对象都有一个对应的整数索引值。vector只能对已存在的元素进行下标操作。下标操作不能添加元素。添加元素应该使用push_back函数。

迭代器：

迭代器是一种检查容器内元素并遍历元素的数据类型。标准库为每一种容器都定义了一种迭代器类型。每个容器都定义了begin和end函数用于返回迭代器，分别指向第一个元素和最后一个元素。

任何改变vector长度得操作都会使已存在得迭代器失效。

## 数组和指针

c++程序被阉割限制于程序内部使用，只有当性能测试表明使用vector无法达到必要得到速度要求时，才使用数组。

数组得维数必须用值大于等于1的常量表达式定义。（非const变量以及要到运行阶段才知道值得const变量都不能用于定义数组得维数）

显式初始化数组元素时，把初值用花括号括起来，显示初始化得数组不需要制定数组的维数值。

指针：

对指针进行初始化或赋值只能使用以下四种类型的值：

1.0值常量表达式

2.类型匹配的对象的地址

3.另一对之后的下一地址

4.同类型的另一个有效指针

在表达式中使用数组名时，改名字会自动转换为指向数组第一个元素的指针。

可以使用数组初始化vector对象

```c++
const size_t arr_size=6;
int int_arr[arr_size]={0,1,2,3};
vector<int> ivec(int_arr,int_arr+4);
```

## 表达式

短路求值：逻辑与和逻辑或操作符总是先计算其左操作数，然后再计算其右操作数。只有在仅靠左操作数无法确定结果时，才会求解其右操作数。

箭头操作符：c++语言为包含点操作符和解引用操作符的表达式提供了一个同义词：箭头操作符（->）和点操作符。

强制类型转换：cast-name<type>(expression);cast-name为static_cast , dynamic_cast, const_cast, reinterpret_cast之一。

## 语句

对于switch语句，漏写break语句是常见的错误。

它的计算顺序如下:
(1) 循环开始时，执行一次init-statement (初始化语句)。在这个例子中，定义了ind,并将
它初始化为0。
(2)接着，求解condition (循环条件)。如果ind不等于svec.size0,则执行for循环体。
08否则， 循环结束。如果在第一次循环时，条件就为false,则不执行for循环体。
(3)如果条件为true,则执行for循环体。本例中，for 循环体输出当前元素值，并检验这
个元素是否是最后一个。如果不是，则输出一个空格，用于分隔当前元素和下一个元素。
(4) 最后，求解expression。本例中，ind 自增1。

## 函数

赋值实参的局限性：

- 当需要再函数中修改实参的值时
- 当需要以大型对象作为实参传递时，对实际的应用而言，复制对象所付出的时间和存储空间代价往往过大。
- 当没有办法实现对象的复制时

对于上述几种情况，有效的解决方法时将实参定义为引用或指针类型。

利用const引用可以避免复制

在向函数传递大型对象时，需要使用引用形参，这是引用形参适用的另一种情况。虽然复制实参对于内置数据类型的对象或者规模较小的类类型对象来说没有什么问题，但是对于大部分的 类类型或者大型数组，它的效率(通常)太低了；此外，我们将在第13章学习到，某些类类型 是无法复制的。使用引用形参，函数可以直接访问实参对象，而无须复制它。 

如果引用形参的唯一目的时避免复制实参，则应将形参定义为const引用。

